COD_CONTROLLO;COD_PROCESSO;COD_TIPO_CONTROLLO;COD_FREQ_CONTROLLO;COD_SEVERITA;DES_CONTROLLO;MSG;STMT_CONTROLLO;FLG_ATTIVO;TMS_CREAZIONE;TMS_MODIFICA;DAT_FINE_VALIDITA;COD_UTENTE_MODIFICA;COD_UTENTE_CREAZIONE
a.1;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica se ci sono valori duplicati nella tabella TE_IRRBB_CURVE_1Y;Nella tabella TE_IRRBB_CURVE_1Y  {dat_report} v{versione_curve_1y} la chiave {output1} viene ripetuta {output2} volte;;Y;;;;;MANUAL
a.2;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica se ci sono valori duplicati nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT;Nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT {dat_report} v{versione_notional_equivalent} la chiave {output1} viene ripetuta {output2} volte;;Y;;;;;MANUAL
a.3;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica se ci sono valori duplicati nella tabella TE_IRRBB_SHOCK_EFFETTIVI;Nella tabella TE_IRRBB_SHOCK_EFFETTIVI  {dat_report} v{versione_shock_effettivi} la chiave {output1} viene ripetuta {output2} volte;;Y;;;;;MANUAL
a.4;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica se ci sono valori duplicati nella tabella TE_IRRBB_MAPPING_ENTITY;Nella tabella TE_IRRBB_MAPPING_ENTITY  {dat_report} v{versione_mapping_entity} la chiave {output1} viene ripetuta {output2} volte;;Y;;;;;MANUAL
a.5;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica se ci sono valori duplicati nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT_BASE;Nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT_BASE {dat_report} v{versione_notional_equivalent_base} la chiave {output1} viene ripetuta {output2} volte;;Y;;;;;MANUAL
1;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che tutti i COD_VALUTA_FINALE presenti in TE_IRRBB_NOTIONAL_EQUIVALENT siano presenti nel campo COD_VALUTA della tabella TE_IRRBB_CURVE_1Y;Il COD_VALUTA_FINALE {output1} risulta presente in TE_IRRBB_NOTIONAL_EQUIVALENT {dat_report} v{versione_notional_equivalent} ma non in COD_VALUTA della tabella TE_IRRBB_CURVE_1Y {dat_report} v{versione_curve_1y};SELECT  COMPLETO.output1, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM   `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE DAT_REPORT ='{dat_report}'   AND ID_VERSIONE = {versione_notional_equivalent} ) RISULTATO LEFT JOIN (SELECT DISTINCT A.COD_VALUTA_FINALE AS output1,   1 as riferimento FROM (   SELECT     COD_VALUTA_FINALE FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE = {versione_notional_equivalent} ) A LEFT JOIN (   SELECT     COD_VALUTA FROM     `{PROJECT_ID}.{DATASET_ECAP}.{CURVE_1Y}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE ={versione_curve_1y} ) B ON   A.COD_VALUTA_FINALE = B.COD_VALUTA WHERE   B.COD_VALUTA IS NULL ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento) ;Y;;;;;MANUAL
2;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che tutti i COD_ENTITY presenti in TE_IRRBB_NOTIONAL_EQUIVALENT siano anche presenti in TE_IRRBB_MAPPING_ENTITY;Il COD_ENTITY {output1} risulta presente in TE_IRRBB_NOTIONAL_EQUIVALENT {dat_report} v{versione_notional_equivalent} ma non in TE_IRRBB_MAPPING_ENTITY {dat_report} v{versione_mapping_entity};SELECT  COMPLETO.output1, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE DAT_REPORT ='{dat_report}'   AND ID_VERSIONE = {versione_notional_equivalent} ) RISULTATO LEFT JOIN (SELECT DISTINCT A.COD_ENTITY AS output1,   1 as riferimento FROM (   SELECT     COD_ENTITY FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE = {versione_notional_equivalent} ) A LEFT JOIN (   SELECT     COD_ENTITY FROM     `{PROJECT_ID}.{DATASET_ECAP}.{MAPPING_ENTITY}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE ={versione_mapping_entity} ) B ON   A.COD_ENTITY = B.COD_ENTITY WHERE   B.COD_ENTITY IS NULL ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento) ;Y;;;;;MANUAL
3;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che tutti i DES_SHOCK_FINALE presenti in TE_IRRBB_NOTIONAL_EQUIVALENT siano anche presenti in TE_IRRBB_SHOCK_EFFETTIVI;Il DES_SHOCK_FINALE {output1} risulta presente in TE_IRRBB_NOTIONAL_EQUIVALENT {dat_report} v{versione_notional_equivalent} ma non in TE_IRRBB_SHOCK_EFFETTIVI {dat_report} v{versione_shock_effettivi};SELECT  COMPLETO.output1, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE DAT_REPORT ='{dat_report}'   AND ID_VERSIONE = {versione_notional_equivalent} ) RISULTATO LEFT JOIN (SELECT DISTINCT A.DES_SHOCK_FINALE AS output1,   1 as riferimento FROM (   SELECT     DES_SHOCK_FINALE FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE = {versione_notional_equivalent} ) A LEFT JOIN (   SELECT     DES_SHOCK_FINALE FROM     `{PROJECT_ID}.{DATASET_ECAP}.{SHOCK_EFFETTIVI}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE ={versione_shock_effettivi} ) B ON   A.DES_SHOCK_FINALE = B.DES_SHOCK_FINALE WHERE   B.DES_SHOCK_FINALE IS NULL ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento) ;Y;;;;;MANUAL
4;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che nella tabella TE_IRRBB_CURVE_1Y, per ogni valuta COD_VALUTA, per ogni anno ID_YEAR e per ogni scenario ID_SCEN, il numero di righe sia uguale;Nella tabella TE_IRRBB_CURVE_1Y {dat_report} v{versione_curve_1y}, per ogni valuta,anno e scenario, ci sono {output1} valori diversi di numero di righe;SELECT  COMPLETO.output1, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM  `{PROJECT_ID}.{DATASET_ECAP}.{CURVE_1Y}` WHERE     DAT_REPORT ='{dat_report}' AND ID_VERSIONE ={versione_curve_1y} ) RISULTATO LEFT JOIN (SELECT count(distinct NUM_ROWS) as output1, 1 as riferimento FROM (SELECT distinct COD_VALUTA, ID_SCEN, ID_YEAR, count(*) as NUM_ROWS FROM `{PROJECT_ID}.{DATASET_ECAP}.{CURVE_1Y}` WHERE DAT_REPORT ='{dat_report}' AND ID_VERSIONE ={versione_curve_1y} group by COD_VALUTA, ID_SCEN, ID_YEAR ) HAVING count(distinct NUM_ROWS)!= 1 ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento);Y;;;;;MANUAL
5;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che nella tabella TE_IRRBB_CURVE_1Y, per ogni valuta COD_VALUTA  e per ogni anno ID_YEAR devono esistere lo scenario 0 e lo scenario -1.;Nella tabella TE_IRRBB_CURVE_1Y {dat_report} v{versione_curve_1y} non esiste lo scenario 0 o lo scenario -1 per la coppia valuta e anno: {output1};SELECT COMPLETO.output1, RISULTATO.conteggio FROM ( SELECT COUNT(1) AS conteggio, 1 AS riferimento FROM `{project_id}.{DATASET_ECAP}.{CURVE_1Y}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_curve_1y} ) RISULTATO LEFT JOIN ( SELECT CONCAT(COD_VALUTA,'|',ID_YEAR) AS output1, 1 AS riferimento FROM `{project_id}.{DATASET_ECAP}.{CURVE_1Y}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_curve_1y} AND (COD_VALUTA, ID_YEAR) NOT IN ( SELECT (COD_VALUTA, ID_YEAR) FROM `{project_id}.{DATASET_ECAP}.{CURVE_1Y}` WHERE dat_report = '{dat_report}'AND ID_VERSIONE = {versione_curve_1y} AND ID_SCEN = 0 GROUP BY COD_VALUTA, ID_YEAR ) OR (COD_VALUTA, ID_YEAR) NOT IN ( SELECT (COD_VALUTA, ID_YEAR) FROM `{project_id}.{DATASET_ECAP}.{CURVE_1Y}` WHERE dat_report = '{dat_report}'AND ID_VERSIONE = {versione_curve_1y} AND ID_SCEN = -1 GROUP BY COD_VALUTA, ID_YEAR ) GROUP BY COD_VALUTA, ID_YEAR ) COMPLETO ON (COMPLETO.riferimento = RISULTATO.riferimento);Y;;;;;MANUAL
6;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che tutti i COD_VALUTA_FINALE presenti in TE_IRRBB_NOTIONAL_EQUIVALENT_BASE siano presenti nel campo COD_VALUTA della tabella TE_IRRBB_CURVE_1Y;Il COD_VALUTA_FINALE {output1} risulta presente in TE_IRRBB_NOTIONAL_EQUIVALENT_BASE {dat_report} v{versione_notional_equivalent_base} ma non in COD_VALUTA della tabella TE_IRRBB_CURVE_1Y {dat_report} v{versione_curve_1y};SELECT  COMPLETO.output1, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT_BASE}` WHERE DAT_REPORT ='{dat_report}'   AND ID_VERSIONE = {versione_notional_equivalent_base} ) RISULTATO LEFT JOIN (SELECT DISTINCT A.COD_VALUTA_FINALE AS output1,   1 as riferimento FROM (   SELECT     COD_VALUTA_FINALE FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT_BASE}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE = {versione_notional_equivalent_base} ) A LEFT JOIN (   SELECT     COD_VALUTA FROM     `{PROJECT_ID}.{DATASET_ECAP}.{CURVE_1Y}` WHERE     DAT_REPORT ='{dat_report}'     AND ID_VERSIONE ={versione_curve_1y} ) B ON   A.COD_VALUTA_FINALE = B.COD_VALUTA WHERE   B.COD_VALUTA IS NULL ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento) ;Y;;;;;MANUAL
7;ecap11_irrbb_ecap;1;DAY;ERROR;Verifica che per ogni coppia COD_VALUTA_FINALE/COD_ENTITY presente nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT sia presente un solo scenario (DES_SHOCK_FINALE) oppure siano presenti tutti gli scenari di shock esistenti.;La coppia COD_VALUTA_FINALE|COD_ENTITY: {output1} presente nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT ha un numero di scenari di shock distinti (DES_SHOCK_FINALE) errato e pari a {output2}.;SELECT  COMPLETO.output1, COMPLETO.output2, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report ='{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent} ) RISULTATO LEFT JOIN( SELECT output1, count_distinct_DES_SHOCK as output2, 1 as riferimento FROM ( SELECT  concat(COD_ENTITY, '|', COD_VALUTA_FINALE) as output1, count(DISTINCT(DES_SHOCK_FINALE)) as count_distinct_DES_SHOCK FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent} group by COD_ENTITY, COD_VALUTA_FINALE order by count(DISTINCT(DES_SHOCK_FINALE)) ) WHERE count_distinct_DES_SHOCK != (SELECT COUNT(DISTINCT(DES_SHOCK_FINALE) ) FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent}  ) AND (count_distinct_DES_SHOCK != 1) ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento);Y;;;;;MANUAL
8;ecap11_irrbb_ecap;1;DAY;ERROR;Nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT, verifica che per ogni coppia COD_VALUTA_FINALE/COD_ENTITY, nel caso in cui sia presente un solo scenario (DES_SHOCK_FINALE), deve esssere uguale a quello inserito dall’utente come scenario_no_prepayment.;La coppia COD_VALUTA_FINALE|COD_ENTITY: {output1} presente nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT ha un un solo scenario di shock (DES_SHOCK_FINALE) che vale {output2} e non coincide con quello inserito dall’utente come scenario_no_prepayment.;SELECT  COMPLETO.output1, COMPLETO.output2, RISULTATO.conteggio FROM  (SELECT COUNT(1) as conteggio,   1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report ='{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent} ) RISULTATO LEFT JOIN( SELECT distinct concat(COD_ENTITY, '|', COD_VALUTA_FINALE) as output1, DES_SHOCK_FINALE as output2, 1 as riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report ='{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent} AND (COD_ENTITY, COD_VALUTA_FINALE) IN ( SELECT  (COD_ENTITY, COD_VALUTA_FINALE) FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report ='{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent} group by COD_ENTITY, COD_VALUTA_FINALE HAVING count(DISTINCT(DES_SHOCK_FINALE))=1 ) AND DES_SHOCK_FINALE != '{scenario_no_prepayment}' ) COMPLETO ON   (COMPLETO.riferimento = RISULTATO.riferimento);Y;;;;;MANUAL
9;ecap11_irrbb_ecap;1;DAY;ERROR;"Verifica che tutte le coppie COD_VALUTA_FINALE/COD_ENTITY presenti nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT siano anche presenti nella tabella TE_IRRBB_NOTIONAL_EQUIVALENT_BASE.
 ";"La coppia COD_VALUTA_FINALE/COD_ENTITY {output1} risulta presente in TE_IRRBB_NOTIONAL_EQUIVALENT {dat_report} v{versione_notional_equivalent} ma non in TE_IRRBB_NOTIONAL_EQUIVALENT_BASE {dat_report} v{versione_notional_equivalent_base}.
";SELECT COMPLETO.output1, RISULTATO.conteggio FROM ( SELECT COUNT(1) AS conteggio, 1 AS riferimento FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent}) RISULTATO LEFT JOIN ( SELECT DISTINCT chiave_notional_equivalent AS output1, 1 AS riferimento FROM ( SELECT DISTINCT CONCAT(COD_VALUTA_FINALE, '|', COD_ENTITY) AS chiave_notional_equivalent FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent}) NOTIONAL_EQUIVALENT LEFT JOIN ( SELECT DISTINCT CONCAT(COD_VALUTA_FINALE, '|', COD_ENTITY) AS chiave_notional_equivalent_base FROM `{PROJECT_ID}.{DATASET_ECAP}.{NOTIONAL_EQUIVALENT_BASE}` WHERE dat_report = '{dat_report}' AND ID_VERSIONE = {versione_notional_equivalent_base} ) NOTIONAL_EQUIVALENT_BASE ON NOTIONAL_EQUIVALENT.chiave_notional_equivalent = NOTIONAL_EQUIVALENT_BASE.chiave_notional_equivalent_base WHERE NOTIONAL_EQUIVALENT_BASE.chiave_notional_equivalent_base IS NULL) COMPLETO ON (COMPLETO.riferimento = RISULTATO.riferimento);Y;;;;;MANUAL
